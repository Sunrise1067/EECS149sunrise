 target C {
  platform: "RP2040",
  threading: false,
  keepalive: true
}

import Display from "lib/Display.lf" 

preamble {=
  #include <hardware/gpio.h>
  #include <hardware/timer.h>
  #include <hardware/irq.h>
  #include <pico/stdlib.h>
  #define ALARM_NUM 0
  #define ALARM_IRQ 0
=}

main reactor {
    physical action timer_end

  preamble {=
    static void* timer_end_ptr;

    typedef void (*virtual_timer_callback_t)(void);
 
    // Definition of linked list node 
    typedef struct node_t {
      /* Put the variables needed for linked list node here */
      // value for the timer
      uint32_t timer_value;

      virtual_timer_callback_t cb;

      bool repeat;

      uint32_t period;


      /*********************************************
          DO NOT CHANGE THE CODE BELOW
      *********************************************/
      // next node pointer
      struct node_t * next ;
      } node_t ;

    //The linked list for timer
    static node_t* linked_list = NULL;

    // linked list operation functions
    // insert the node in the sorted linked list (linked_list) and return the sorted linked list after the insertion
    void list_insert_sorted(node_t* node){

       if(linked_list == NULL){
          node -> next = NULL;
          linked_list = node;
       }
       else{
          if(linked_list -> timer_value > node -> timer_value){
              node -> next = linked_list;
              linked_list = node;
            }     
          else{
              // node is somewhere after the head
              node_t* prev_node = linked_list;
              node_t* curr_node = linked_list->next;
              while(curr_node != NULL && curr_node -> timer_value < node -> timer_value){
                  // iterate until end of list or the current node has a greater value
                  prev_node = curr_node;
                  curr_node = curr_node -> next;
              }
              // insert node
              prev_node -> next = node;
              node -> next = curr_node;
          } 
       }
    }

    // remove the node from linked list
    void list_remove(node_t* node){
        if(linked_list != NULL){
            if(linked_list == node){
                linked_list = linked_list -> next;
            }
            else{
                node_t* prev_node = linked_list;
                node_t* curr_node = linked_list -> next;
                while(curr_node != NULL && curr_node != node){
                    prev_node = curr_node;
                    curr_node = curr_node -> next;
                }
                if(curr_node != NULL){
                    prev_node -> next = curr_node -> next; 
                }
            }
        }
    }
    // return and remove the first node in the linked list
    node_t* list_remove_first(){
      node_t* head = linked_list;
      if (head != NULL) {
          linked_list = head->next;
      }
      return head;
    }
    /*********************************************
        DO NOT CHANGE THE CODE ABOVE
    *********************************************/

    /* You can also create your own linked list functions here. */
    #define ALARM_NUM 0
    #define TIMER_BASE 0x40054000

    void lab5_timer_irq_handler(void){
        irq_set_enabled(ALARM_IRQ, false);  // Interrupt false
        uint32_t timeraw = timer_hw->timerawl; 
        node_t *cursor = linked_list;

        while (cursor != NULL) {
            printf("cursor inc\n");
            node_t *next = cursor->next;

            if(timeraw >= cursor->timer_value) {
                printf("lab5_timer_irq_handler: finished timer with timer_value %d\n", cursor->timer_value);
                if (cursor->cb)
                    cursor->cb();
                list_remove(cursor);

                if(cursor->repeat) {
                    printf("repeated timer encountered\n");
                    cursor->timer_value += cursor->period;
                    list_insert_sorted(cursor);
                    cursor = linked_list;
                    continue;
                } else {
                    free(cursor);
                }
            }

            cursor = next;
        }



        hw_clear_bits(&timer_hw->intr, 1u << ALARM_NUM);

        // Restart the timer if there is another value
        if (linked_list != NULL)
            timer_hw->alarm[ALARM_NUM] = linked_list->timer_value;
        
        irq_set_enabled(ALARM_IRQ, true);  // Interrupt true

    }
    void virtual_timer_init(void){
        hw_set_bits(&timer_hw->inte, 1u << ALARM_NUM);
        irq_set_exclusive_handler(ALARM_IRQ, lab5_timer_irq_handler);
        irq_set_enabled(ALARM_IRQ, true);
    }
    uint32_t virtual_timer_start(uint32_t microseconds, virtual_timer_callback_t cb){
        bool is_first = linked_list == NULL;
        node_t *head = linked_list;

        node_t *node = malloc(sizeof(node_t));
        node->timer_value = timer_hw->timerawl + microseconds;
        node->repeat = false;
        node->period = 0;
        node->cb = cb;
        list_insert_sorted(node);

        if(linked_list == node)
        {
            hw_clear_bits(&timer_hw->intr, 1u << ALARM_NUM);
            timer_hw->alarm[ALARM_NUM] = linked_list->timer_value;
        }

        // Write the lower 32 bits of the target time to the alarm which
        // will arm it

        return node->timer_value;
    }
    uint32_t virtual_timer_start_repeated(uint32_t microseconds, virtual_timer_callback_t cb){
        bool is_first = linked_list == NULL;
        node_t *head = linked_list;


        node_t *node = malloc(sizeof(node_t));
        node->timer_value = timer_hw->timerawl + microseconds;
        node->repeat = true;
        node->period = microseconds;
        node->cb = cb;
        list_insert_sorted(node);

        if(linked_list == node)
        {
            hw_clear_bits(&timer_hw->intr, 1u << ALARM_NUM);
            timer_hw->alarm[ALARM_NUM] = linked_list->timer_value;
        }

        // Write the lower 32 bits of the target time to the alarm which
        // will arm it

        return (uint32_t) node;
    }
    void virtual_timer_cancel(uint32_t time_id ){
        node_t *cursor = (node_t *)time_id;

        list_remove(cursor);
        free(cursor);

        if (linked_list == NULL) {
            hw_clear_bits(&timer_hw->inte, 1u << ALARM_NUM);
            timer_hw -> alarm[ALARM_NUM] = UINT32_MAX;
          }
    }

    void first_timer_callback(void) {
        printf("first timer callback called (5 seconds)\n");
        gpio_put(PICO_DEFAULT_LED_PIN, false);
    }

    void second_timer_callback(void) {
        printf("second timer callback called (10 seconds)\n");
        gpio_put(PICO_DEFAULT_LED_PIN, true);
    }

    void on_callback(void) {
        static bool is_on = false;

        printf("on callback %s\n", is_on ? "on": "off");
        gpio_put(PICO_DEFAULT_LED_PIN, is_on);
        is_on = !is_on;
    }

//9.2.8
    // void led0_toggle(void) {
    //       static bool is_on = false;
    //       gpio_put(PICO_DEFAULT_LED_PIN, is_on);
    //       is_on = !is_on;
    //   }
  
    //   void do_nothing(void) {
    //       printf("do_nothing callback fired\n");
    //   }
  

  =}


    state timerid: uint32_t = 0

    timer cancel_t(5100ms)

  // timer print_hw_timer(0, 5000ms)

  reaction(startup) -> timer_end {=
    timer_end_ptr = timer_end;
      // initialize the LED and the virtual timer    
      gpio_init(PICO_DEFAULT_LED_PIN);
      gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
      gpio_put(25, true);
      virtual_timer_init();

    //   9.2.6
    self->timerid = virtual_timer_start_repeated(1 * 1000000, on_callback);


        // 9.2.7
        // virtual_timer_start(1 * 1000000, first_timer_callback);
        // virtual_timer_start(2 * 1000000, second_timer_callback);
        // virtual_timer_start(3 * 1000000, first_timer_callback);
        // virtual_timer_start(4 * 1000000, second_timer_callback);
        // virtual_timer_start(5 * 1000000, first_timer_callback);
        // virtual_timer_start(6 * 1000000, second_timer_callback);


        
  =}

    //9.2.6
    reaction(cancel_t) {=
        virtual_timer_cancel(self->timerid);
    =}

  
  // reaction(print_hw_timer) -> disp.line0 {=
  //     uint32_t lo = timer_hw->timelr;

  //     static char buf[17];
  //     snprintf(buf, 17, "t: %d", lo);
  //     lf_set(disp.line0, buf);
  // =}


  /* TODO: add reaction and timer to create the environment to test */
}
