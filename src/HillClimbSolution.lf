/**
 * Display the outputs from the line sensors on the
 * <a href="https://www.pololu.com/docs/0J86">Pololu 3pi+ 2040 robot</a>. This program spends the
 * first 10 seconds in calibration mode, during which you should move the robot over the light and
 * dark areas that you would like it to detect. It then switches into measurement mode and displays
 * the measured reflectance of the five IR sensors.
 *
 * @author Abhi Gundrala
 * @author Edward A. Lee
 */
 target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    single-threaded: true
  }

  import Display from "lib/Display.lf"
  import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
  import tilt from "lib/tilt.lf"
  import Accelerometer from "lib/IMU.lf"
  import GyroAngle from "lib/IMU.lf"
  import Encoders from "lib/Encoders.lf"
  

  reactor Robot {
    input state_R: int
    output notify: string
    output P:float
    output R:float
    output A:float
    output left_disp:int32_t
    output right_disp:int32_t
    Motor = new MotorsWithFeedback()
    tilt_1 = new tilt()
    acceleration = new Accelerometer()
    encoder = new Encoders()
    angle = new GyroAngle()
    timer t_R(0, 100ms)
    state pre_angle:float = 0.0

    reaction(t_R)-> acceleration.trigger, angle.trigger, encoder.trigger
    {=
      lf_set(acceleration.trigger, true);
      lf_set(angle.trigger, true);
      lf_set(encoder.trigger, true);
    =}

    acceleration.x -> tilt_1.x
    acceleration.y -> tilt_1.y
    acceleration.z -> tilt_1.z



    reaction(tilt_1.pitch,tilt_1.roll,angle.z,encoder.left,encoder.right)-> P,R,A,left_disp,right_disp
    {=
      lf_set(left_disp, encoder.left->value);
      lf_set(right_disp, encoder.right->value);
      lf_set(P, tilt_1.pitch->value);
      lf_set(R, tilt_1.roll->value);
      lf_set(A, angle.z->value - self->pre_angle);
    =}

  initial mode CALIBRATING
  {
    reaction(tilt_1.pitch,tilt_1.roll,encoder.left,encoder.right) ->reset(UP), Motor.left_speed, Motor.right_speed, Motor.left, Motor.right, notify{=
      lf_set(Motor.left, encoder.left->value);
      lf_set(Motor.right, encoder.right->value);
      lf_set(notify, "CALIBRATING");

      if(tilt_1.roll->value < -2)
      {
        lf_set(Motor.left_speed,-0.15f);
        lf_set(Motor.right_speed,0.15f);
      }
      else if(tilt_1.roll->value > 2)
      {
        lf_set(Motor.left_speed,0.15f);
        lf_set(Motor.right_speed,-0.15f);
      }
      else
      {
        lf_set(Motor.left_speed,0.0f);
        lf_set(Motor.right_speed,0.0f);
        lf_set_mode(UP);
        lf_set(notify, "UP");
      }
    =}
  }

  mode UP{
    reaction(angle.z,tilt_1.pitch,tilt_1.roll,encoder.left,encoder.right) -> reset(TURNING), Motor.left_speed, Motor.right_speed, Motor.left, Motor.right, notify{=
      lf_set(Motor.left, encoder.left->value);
      lf_set(Motor.right, encoder.right->value);

      if(tilt_1.roll->value < -1)
      {
        lf_set(Motor.left_speed,0.21f);
        lf_set(Motor.right_speed,0.2f);
      }
      else if(tilt_1.roll->value > 1)
      {
        lf_set(Motor.left_speed,0.2f);
        lf_set(Motor.right_speed,0.21f);
      }
      else
      {
        lf_set(Motor.left_speed,0.2f);
        lf_set(Motor.right_speed,0.2f);
      }
      if(tilt_1.pitch->value < 1 && tilt_1.pitch->value > -1 && tilt_1.roll->value < 1 && tilt_1.roll->value > -1)
      {
        lf_set(Motor.left_speed,0.0f);
        lf_set(Motor.right_speed,0.0f);
        lf_set_mode(TURNING);
        lf_set(notify, "TURNING");
        self->pre_angle = angle.z->value;
      }
    =}
  }

  mode TURNING{
    reaction(angle.z,encoder.left,encoder.right) -> reset(DOWN), Motor.left_speed, Motor.right_speed, Motor.left, Motor.right, notify{=
      lf_set(Motor.left, encoder.left->value);
      lf_set(Motor.right, encoder.right->value);

      lf_set(Motor.left_speed,0.15f);
      lf_set(Motor.right_speed,-0.15f);

      while(angle.z->value - self->pre_angle <= -180)
      {
        lf_set(Motor.left_speed,0.0f);
        lf_set(Motor.right_speed,0.0f);
        lf_set_mode(DOWN);
        lf_set(notify, "DOWN");
        self->pre_angle = angle.z->value;
      }
    =}
  }

  mode DOWN{
    reaction(tilt_1.pitch,tilt_1.roll,encoder.left,encoder.right) -> Motor.left_speed, Motor.right_speed, Motor.left, Motor.right, notify{=
      lf_set(Motor.left, encoder.left->value);
      lf_set(Motor.right, encoder.right->value);

      if(tilt_1.roll->value < -1)
      {
        lf_set(Motor.left_speed,0.1f);
        lf_set(Motor.right_speed,0.09f);
      }
      else if(tilt_1.roll->value > 1)
      {
        lf_set(Motor.left_speed,0.09f);
        lf_set(Motor.right_speed,0.1f);
      }
      else
      {
        lf_set(Motor.left_speed,0.1f);
        lf_set(Motor.right_speed,0.1f);
      }
      if(tilt_1.pitch->value < 1 && tilt_1.pitch->value > -1 && tilt_1.roll->value < 1 && tilt_1.roll->value > -1)
      {
        lf_set(Motor.left_speed,0.0f);
        lf_set(Motor.right_speed,0.0f);
      }
    =}
  }
}
    
  main reactor{
    disp = new Display()
    robot = new Robot()

    // reaction(startup) ->  disp.line1, disp.line2 {=
    // //   lf_set(disp.line0, "CALIBRATING");
    //   // lf_set(disp.line1, "Roll robot over");
    //   // lf_set(disp.line2, "light and dark.");
    // =}

    
    robot.notify -> disp.line0
  
    reaction(robot.P,robot.R,robot.A) -> disp.line1, disp.line2, disp.line3{=
    
    static char buf1[17];
    static char buf2[17];
    static char buf3[17];

    snprintf(buf1, 17, "pitch:%.3f", robot.P->value);
    snprintf(buf2, 17, "roll:%.3f", robot.R->value);
    snprintf(buf3, 17, "angle:%.3f", robot.A->value);
    lf_set(disp.line1, buf1);
    lf_set(disp.line2, buf2);
    lf_set(disp.line3, buf3);
    =}
    
   }
  