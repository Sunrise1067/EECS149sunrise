target C {
  platform: "RP2040",
  threading: false,
  keepalive: true
}

import Display from "lib/Display.lf" 

preamble {=
  #include <hardware/gpio.h>
  #include <hardware/timer.h>
  #include <hardware/irq.h>
  #include <pico/stdlib.h>
  #define ALARM_NUM 0
  #define ALARM_IRQ 0
=}

main reactor {
    physical action timer_end

  preamble {=
    static void* timer_end_ptr;

    typedef void (*virtual_timer_callback_t)(void);

    // 定义链表节点结构体
    typedef struct node_t {
      uint32_t timer_value;               // 计时器的触发时间
      virtual_timer_callback_t cb;        // 到期时执行的回调函数
      bool repeat;                        // 是否重复触发
      uint32_t period;                    // 重复触发的周期
      struct node_t *next;                // 下一个节点的指针
    } node_t;

    // 链表头指针
    static node_t* linked_list = NULL;

    // **链表插入**：按触发时间排序插入新计时器节点，禁用中断确保操作原子性
    void list_insert_sorted(node_t* node) {
        irq_set_enabled(ALARM_IRQ, false);  // 禁用中断

        if (linked_list == NULL) {
            node->next = NULL;
            linked_list = node;
        } else {
            if (linked_list->timer_value > node->timer_value) {
                node->next = linked_list;
                linked_list = node;
            } else {
                node_t* prev_node = linked_list;
                node_t* curr_node = linked_list->next;
                while (curr_node != NULL && curr_node->timer_value < node->timer_value) {
                    prev_node = curr_node;
                    curr_node = curr_node->next;
                }
                prev_node->next = node;
                node->next = curr_node;
            }
        }
        
        irq_set_enabled(ALARM_IRQ, true);  // 重新启用中断
    }

    // **链表删除**：从链表中移除指定节点，禁用中断以确保原子性
    void list_remove(node_t* node) {
        irq_set_enabled(ALARM_IRQ, false);  // 禁用中断

        if (linked_list != NULL) {
            if (linked_list == node) {
                linked_list = linked_list->next;
            } else {
                node_t* prev_node = linked_list;
                node_t* curr_node = linked_list->next;
                while (curr_node != NULL && curr_node != node) {
                    prev_node = curr_node;
                    curr_node = curr_node->next;
                }
                if (curr_node != NULL) {
                    prev_node->next = curr_node->next;
                }
            }
        }

        irq_set_enabled(ALARM_IRQ, true);  // 重新启用中断
    }

    // **中断处理程序**：处理触发的计时器并更新下一次报警时间
    void lab5_timer_irq_handler(void) {
        uint32_t timeraw = timer_hw->timerawl;
        irq_set_enabled(ALARM_IRQ, false);  // 禁用中断确保链表一致性

        // 处理所有已过期的计时器
        while (linked_list != NULL && timeraw >= linked_list->timer_value) {
            node_t* node = linked_list;
            linked_list = linked_list->next;  // 从链表中移除当前节点

            if (node->cb) node->cb();         // 调用回调函数

            // 处理重复计时器
            if (node->repeat) {
                node->timer_value += node->period;
                list_insert_sorted(node);     // 重新插入链表
            } else {
                free(node);                   // 释放单次计时器节点
            }
            timeraw = timer_hw->timerawl;     // 更新当前时间
        }

        hw_clear_bits(&timer_hw->intr, 1u << ALARM_NUM);

        // 设置下一个报警时间
        if (linked_list != NULL) {
            timer_hw->alarm[ALARM_NUM] = linked_list->timer_value;
        }

        irq_set_enabled(ALARM_IRQ, true);  // 重新启用中断
    }

    // 初始化计时器系统
    void virtual_timer_init(void) {
        hw_set_bits(&timer_hw->inte, 1u << ALARM_NUM);
        irq_set_exclusive_handler(ALARM_IRQ, lab5_timer_irq_handler);
        irq_set_enabled(ALARM_IRQ, true);
    }

    // 启动单次定时器
    uint32_t virtual_timer_start(uint32_t microseconds, virtual_timer_callback_t cb) {
        node_t *node = malloc(sizeof(node_t));
        node->timer_value = timer_hw->timerawl + microseconds;
        node->repeat = false;
        node->period = 0;
        node->cb = cb;
        list_insert_sorted(node);

        // 检查链表头并更新报警时间
        if (linked_list == node) {
            hw_clear_bits(&timer_hw->intr, 1u << ALARM_NUM);
            timer_hw->alarm[ALARM_NUM] = linked_list->timer_value;
        }

        return node->timer_value;
    }

    // 启动重复定时器
    uint32_t virtual_timer_start_repeated(uint32_t microseconds, virtual_timer_callback_t cb) {
        node_t *node = malloc(sizeof(node_t));
        node->timer_value = timer_hw->timerawl + microseconds;
        node->repeat = true;
        node->period = microseconds;
        node->cb = cb;
        list_insert_sorted(node);

        // 检查链表头并更新报警时间
        if (linked_list == node) {
            hw_clear_bits(&timer_hw->intr, 1u << ALARM_NUM);
            timer_hw->alarm[ALARM_NUM] = linked_list->timer_value;
        }

        return (uint32_t) node;
    }

    // 取消指定计时器
    void virtual_timer_cancel(uint32_t time_id) {
        node_t *cursor = (node_t *)time_id;
        list_remove(cursor);
        free(cursor);
    }

    // 示例回调函数：每秒切换 LED 状态
    void led0_toggle(void) {
        static bool is_on = false;
        gpio_put(PICO_DEFAULT_LED_PIN, is_on);
        is_on = !is_on;
    }

    // 示例回调函数：无操作
    void do_nothing(void) {
        printf("do_nothing callback fired\n");
    }

  =}

  // 启动计时器的反应函数
  reaction(startup) -> timer_end {=
    timer_end_ptr = timer_end;
    gpio_init(PICO_DEFAULT_LED_PIN);
    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
    gpio_put(PICO_DEFAULT_LED_PIN, true);
    virtual_timer_init();
    
    // 启动两个测试定时器
    virtual_timer_start_repeated(1000000, led0_toggle);  // 每秒切换 LED
    virtual_timer_start_repeated(2000000, do_nothing);   // 每2秒打印消息
  =}

  // 显示计时器触发的信息
  reaction(timer_end) -> disp.line0 {=
      static char buf[17];
      snprintf(buf, 17, "timer fired!");
      lf_set(disp.line0, buf);
  =}
}
